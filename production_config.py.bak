#!/usr/bin/env python
"""
Production Configuration for Vanta Core

This module handles the transition from stub implementations to real production
implementations for all Vanta components.
"""

# Import production config and components
import logging
from typing import Any, Dict, Optional

# Import real implementations using absolute imports
try:
    from Vanta.interfaces.real_supervisor_connector import RealSupervisorConnector

    SUPERVISOR_AVAILABLE = True
except ImportError:
    SUPERVISOR_AVAILABLE = False
    RealSupervisorConnector = None

try:
    from BLT.blt_encoder import BLTEncoder

    BLT_ENCODER_AVAILABLE = True
except ImportError:
    BLT_ENCODER_AVAILABLE = False
    BLTEncoder = None

try:
    from BLT.hybrid_middleware import HybridMiddleware

    HYBRID_MIDDLEWARE_AVAILABLE = True
except ImportError:
    HYBRID_MIDDLEWARE_AVAILABLE = False
    HybridMiddleware = None

# Import additional component implementations
try:
    from Vanta.core.cat_engine import CATEngine, CATEngineConfig
    
    CAT_ENGINE_AVAILABLE = True
except ImportError:
    CAT_ENGINE_AVAILABLE = False
    CATEngine = None
    CATEngineConfig = None

try:
    from Vanta.core.proactive_intelligence import ProactiveIntelligence, ProactiveIntelligenceConfig
    
    PROACTIVE_INTELLIGENCE_AVAILABLE = True
except ImportError:
    PROACTIVE_INTELLIGENCE_AVAILABLE = False
    ProactiveIntelligence = None
    ProactiveIntelligenceConfig = None

try:
    from Vanta.core.hybrid_cognition_engine import HybridCognitionEngine, HybridCognitionConfig
    
    HYBRID_COGNITION_AVAILABLE = True
except ImportError:
    HYBRID_COGNITION_AVAILABLE = False
    HybridCognitionEngine = None
    HybridCognitionConfig = None

try:
    from Vanta.core.tot_engine import ToTEngine, ToTEngineConfig
    
    TOT_ENGINE_AVAILABLE = True
except ImportError:
    TOT_ENGINE_AVAILABLE = False
    ToTEngine = None
    ToTEngineConfig = None

# Import new component implementations
try:
    from Vanta.async_stt_engine import AsyncSTTEngine
    
    STT_AVAILABLE = True
except ImportError:
    STT_AVAILABLE = False
    AsyncSTTEngine = None

try:
    from Vanta.async_tts_engine import AsyncTTSEngine
    
    TTS_AVAILABLE = True
except ImportError:
    TTS_AVAILABLE = False
    AsyncTTSEngine = None

try:
    from Vanta.async_processing_engine import AsyncProcessingEngine
    
    PROCESSING_AVAILABLE = True
except ImportError:
    PROCESSING_AVAILABLE = False
    AsyncProcessingEngine = None

try:
    from Vanta.core.echo_memory import EchoMemory
    
    ECHO_MEMORY_AVAILABLE = True
except ImportError:
    ECHO_MEMORY_AVAILABLE = False
    EchoMemory = None

try:
    from Vanta.core.memory_braid import MemoryBraid
    
    MEMORY_BRAID_AVAILABLE = True
except ImportError:
    MEMORY_BRAID_AVAILABLE = False
    MemoryBraid = None

try:
    from Vanta.core.sleep_time_compute import SleepTimeCompute
    
    SLEEP_TIME_COMPUTE_AVAILABLE = True
except ImportError:
    SLEEP_TIME_COMPUTE_AVAILABLE = False
    SleepTimeCompute = None

# Import fallback stubs - use absolute imports for consistency
try:
    from Vanta.core.interfaces import (
        StubBLTEncoder as ImportedStubBLTEncoder,
        StubHybridMiddleware as ImportedStubHybridMiddleware,
        StubSupervisorConnector as ImportedStubSupervisorConnector,
    )

    STUBS_AVAILABLE = True
except ImportError:
    STUBS_AVAILABLE = False

# Create minimal fallback stubs regardless of import status
class StubSupervisorConnector:
    def connect(self):
        return None
    
    def get_sigil_content_as_dict(self, sigil_name):
        return {"status": "stub", "content": {}}

class StubBLTEncoder:
    def encode(self, data):
        return data
    
    def decode(self, encoded_data):
        return encoded_data

class StubHybridMiddleware:
    def process(self, data):
        return data
    
    def process_request(self, request):
        return {"status": "processed", "data": request}


logger = logging.getLogger("VantaCore.ProductionConfig")


class ProductionComponentFactory:
    """Factory for creating production-ready components with fallback to stubs."""    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        Initialize the production component factory.

        Args:
            config: Configuration dictionary with component settings
        """
        self.config = config or {}
        self.use_production = self.config.get("use_production", True)
        self.fallback_to_stubs = self.config.get("fallback_to_stubs", True)
        self.components = {}  # Store created components for inter-component references

        logger.info(
            f"ProductionComponentFactory initialized (production={self.use_production}, fallback={self.fallback_to_stubs})"
        )

    def create_supervisor_connector(self) -> Any:
        """Create supervisor connector - production or stub."""
        if not self.use_production:
            logger.info("Using stub supervisor connector (production disabled)")
            return StubSupervisorConnector()

        try:
            # Try to create real supervisor connector
            voxsigil_path = self.config.get("voxsigil_library_path")
            supervisor_instance = self.config.get("supervisor_instance")

            connector = RealSupervisorConnector(
                voxsigil_library_path=voxsigil_path,
                supervisor_instance=supervisor_instance,
            )
            # Test basic functionality instead of connection
            # Try a simple method call to verify the connector is working
            test_result = connector.get_sigil_content_as_dict("test_sigil")
            logger.info("âœ… Real supervisor connector created and tested successfully")
            return connector

        except ImportError as e:
            logger.error(f"âŒ Failed to import real supervisor connector: {e}")
            if self.fallback_to_stubs:
                logger.info("ðŸ”„ Falling back to stub supervisor connector")
                return StubSupervisorConnector()
            raise
        except Exception as e:
            logger.error(f"âŒ Failed to create real supervisor connector: {e}")
            if self.fallback_to_stubs:
                logger.info("ðŸ”„ Falling back to stub supervisor connector")
                return StubSupervisorConnector()
            raise

    def create_blt_encoder(self) -> Any:
        """Create BLT encoder - production or stub."""
        if not self.use_production:
            logger.info("Using stub BLT encoder (production disabled)")
            return StubBLTEncoder()

        try:
            # Configuration for BLT encoder
            blt_config = self.config.get("blt_encoder", {})

            encoder = BLTEncoder(config=blt_config)

            # Test the encoder
            test_data = "test encoding"
            encoded = encoder.encode(test_data)
            decoded = encoder.decode(encoded)

            logger.info("âœ… Real BLT encoder created and tested successfully")
            return encoder

        except ImportError as e:
            logger.error(f"âŒ Failed to import real BLT encoder: {e}")
            if self.fallback_to_stubs:
                logger.info("ðŸ”„ Falling back to stub BLT encoder")
                return StubBLTEncoder()
            raise
        except Exception as e:
            logger.error(f"âŒ Failed to create real BLT encoder: {e}")
            if self.fallback_to_stubs:
                logger.info("ðŸ”„ Falling back to stub BLT encoder")
                return StubBLTEncoder()
            raise

    def create_hybrid_middleware(self) -> Any:
        """Create hybrid middleware - production or stub."""
        if not self.use_production:
            logger.info("Using stub hybrid middleware (production disabled)")
            return StubHybridMiddleware()

        try:
            # Configuration for hybrid middleware
            middleware_config = self.config.get("hybrid_middleware", {})

            middleware = HybridMiddleware(config=middleware_config)

            # Test the middleware
            test_request = {"test": "request", "data": "sample"}
            processed = middleware.process_request(test_request)

            logger.info("âœ… Real hybrid middleware created and tested successfully")
            return middleware

        except ImportError as e:
            logger.error(f"âŒ Failed to import real hybrid middleware: {e}")
            if self.fallback_to_stubs:
                logger.info("ðŸ”„ Falling back to stub hybrid middleware")
                return StubHybridMiddleware()
            raise
        except Exception as e:
            logger.error(f"âŒ Failed to create real hybrid middleware: {e}")
            if self.fallback_to_stubs:
                logger.info("ðŸ”„ Falling back to stub hybrid middleware")
                return StubHybridMiddleware()
            raise

    def create_art_interface(self) -> Any:
        """Create ART interface - production or stub."""
        if not self.use_production:
            logger.info("Using stub ART interface (production disabled)")
            from Vanta.interfaces.art_interface import StubARTInterface

            return StubARTInterface()

        try:
            # Import and create production ART interface using absolute imports
            from Vanta.interfaces.art_interface import create_art_interface

            # Configuration for ART interface
            art_config = self.config.get("art_interface", {})

            art_interface = create_art_interface(config=art_config, use_production=True)

            # Test the interface with a simple analysis
            test_result = art_interface.analyze_input("test input for ART analysis")

            logger.info("âœ… Real ART interface created and tested successfully")
            return art_interface

        except ImportError as e:
            logger.error(f"âŒ Failed to import real ART interface: {e}")
            if self.fallback_to_stubs:
                logger.info("ðŸ”„ Falling back to stub ART interface")
                from Vanta.interfaces.art_interface import StubARTInterface

                return StubARTInterface()
            raise
        except Exception as e:
            logger.error(f"âŒ Failed to create real ART interface: {e}")
            if self.fallback_to_stubs:
                logger.info("ðŸ”„ Falling back to stub ART interface")
                from Vanta.interfaces.art_interface import StubARTInterface

                return StubARTInterface()
            raise

    def create_stt_engine(self) -> Any:
        """Create speech-to-text engine - production or stub."""
        if not self.use_production or not STT_AVAILABLE:
            logger.info("Using stub STT engine")
            # Return a simple stub
            class StubSTTEngine:
                def __init__(self, *args, **kwargs):
                    pass
                
                async def transcribe(self, audio_path):
                    return {"text": "Stub transcription", "confidence": 1.0}
            
            return StubSTTEngine()
        
        try:
            # Create a production STT engine
            stt_config = self.config.get("stt_config", {})
            stt_engine = AsyncSTTEngine(vanta_core=None, config=stt_config)
            logger.info("Created production AsyncSTTEngine")
            return stt_engine
        except Exception as e:
            logger.error(f"Error creating AsyncSTTEngine: {e}")
            if self.fallback_to_stubs:
                return self.create_stt_engine()  # Will return stub
            raise
    
    def create_tts_engine(self) -> Any:
        """Create text-to-speech engine - production or stub."""
        if not self.use_production or not TTS_AVAILABLE:
            logger.info("Using stub TTS engine")
            # Return a simple stub
            class StubTTSEngine:
                def __init__(self, *args, **kwargs):
                    pass
                
                async def synthesize(self, text):
                    return {"success": True, "audio_path": None, "text": text}
            
            return StubTTSEngine()
        
        try:
            # Create a production TTS engine
            tts_config = self.config.get("tts_config", {})
            tts_engine = AsyncTTSEngine(vanta_core=None, config=tts_config)
            logger.info("Created production AsyncTTSEngine")
            return tts_engine
        except Exception as e:
            logger.error(f"Error creating AsyncTTSEngine: {e}")
            if self.fallback_to_stubs:
                return self.create_tts_engine()  # Will return stub
            raise
    
    def create_processing_engine(self) -> Any:
        """Create processing engine - production or stub."""
        if not self.use_production or not PROCESSING_AVAILABLE:
            logger.info("Using stub processing engine")
            # Return a simple stub
            class StubProcessingEngine:
                def __init__(self, *args, **kwargs):
                    pass
                
                async def process(self, data):
                    return {"result": data, "status": "success"}
            
            return StubProcessingEngine()
        
        try:
            # Create a production processing engine
            processor_config = self.config.get("processor_config", {})
            processing_engine = AsyncProcessingEngine(vanta_core=None, config=processor_config)
            logger.info("Created production AsyncProcessingEngine")
            return processing_engine
        except Exception as e:
            logger.error(f"Error creating AsyncProcessingEngine: {e}")
            if self.fallback_to_stubs:
                return self.create_processing_engine()  # Will return stub
            raise
    
    def create_echo_memory(self) -> Any:
        """Create echo memory - production or stub."""
        if not self.use_production or not ECHO_MEMORY_AVAILABLE:
            logger.info("Using stub echo memory")
            # Return a simple stub
            class StubEchoMemory:
                def __init__(self, *args, **kwargs):
                    self.events = []
                
                def log_event(self, event_data):
                    self.events.append(event_data)
                    return True
                
                def retrieve_events(self, task_id=None):
                    return self.events
            
            return StubEchoMemory()
        
        try:
            # Create a production echo memory
            memory_config = self.config.get("echo_memory_config", {})
            max_log_size = memory_config.get("max_log_size", 10000)
            enable_persistence = memory_config.get("enable_persistence", False)
            persistence_path = memory_config.get("persistence_path", None)
            
            echo_memory = EchoMemory(
                max_log_size=max_log_size,
                enable_persistence=enable_persistence,
                persistence_path=persistence_path
            )
            logger.info("Created production EchoMemory")
            return echo_memory
        except Exception as e:
            logger.error(f"Error creating EchoMemory: {e}")
            if self.fallback_to_stubs:
                return self.create_echo_memory()  # Will return stub
            raise
    
    def create_memory_braid(self) -> Any:
        """Create memory braid - production or stub."""
        if not self.use_production or not MEMORY_BRAID_AVAILABLE:
            logger.info("Using stub memory braid")
            # Return a simple stub
            class StubMemoryBraid:
                def __init__(self, *args, **kwargs):
                    self.memory = {}
                
                def imprint(self, key, value):
                    self.memory[key] = value
                    return True
                
                def recall(self, key):
                    return self.memory.get(key)
            
            return StubMemoryBraid()
        
        try:
            # Create a production memory braid
            braid_config = self.config.get("memory_braid_config", {})
            max_episodic_len = braid_config.get("max_episodic_len", 128)
            default_semantic_ttl_seconds = braid_config.get("default_semantic_ttl_seconds", 3600)
            
            memory_braid = MemoryBraid(
                max_episodic_len=max_episodic_len,
                default_semantic_ttl_seconds=default_semantic_ttl_seconds
            )
            logger.info("Created production MemoryBraid")
            return memory_braid
        except Exception as e:
            logger.error(f"Error creating MemoryBraid: {e}")
            if self.fallback_to_stubs:
                return self.create_memory_braid()  # Will return stub
            raise
      def create_sleep_time_compute(self) -> Any:
        """Create sleep time compute - production or stub."""
        if not self.use_production or not SLEEP_TIME_COMPUTE_AVAILABLE:
            logger.info("Using stub sleep time compute")
            # Return a simple stub
            class StubSleepTimeCompute:
                def __init__(self, *args, **kwargs):
                    pass
                
                def get_current_state(self):
                    return "ACTIVE"
                
                def process_rest_phase(self):
                    return {"status": "success", "processed_items": 0}
                
                def add_memory_for_processing(self, memory_item):
                    return True
            
            return StubSleepTimeCompute()
        
        try:
            # Create a production sleep time compute
            stc_config = self.config.get("sleep_time_compute_config", {})
            # Only pass the config parameter, not logger
            sleep_time_compute = SleepTimeCompute(
                config=stc_config
            )
            logger.info("Created production SleepTimeCompute")
            return sleep_time_compute
        except Exception as e:
            logger.error(f"Error creating SleepTimeCompute: {e}")
            if self.fallback_to_stubs:
                return self.create_sleep_time_compute()  # Will return stub
            raise
    
    def create_cat_engine(self) -> Any:
        """Create CAT engine - production or stub."""
        if not self.use_production or not CAT_ENGINE_AVAILABLE:
            logger.info("Using stub CAT engine")
            # Return a simple stub
            class StubCATEngine:
                def __init__(self, *args, **kwargs):
                    self.state = "inactive"
                
                def activate(self):
                    self.state = "active"
                    return True
                
                def process_input(self, input_data):
                    return {"processed": True, "result": input_data}
                
                def get_state(self):
                    return {"state": self.state}
            
            return StubCATEngine()
        
        try:
            # Create a production CAT engine
            cat_config = self.config.get("cat_engine_config", {})
            cat_engine_config = CATEngineConfig(
                interval_s=cat_config.get("interval_s", 300),
                log_level=cat_config.get("log_level", "INFO")
            )
            
            # We'll use None for vanta_core, it will be set later in the initialization process
            cat_engine = CATEngine(
                vanta_core=None,
                config=cat_engine_config
            )
            logger.info("Created production CATEngine")
            return cat_engine
        except Exception as e:
            logger.error(f"Error creating CATEngine: {e}")
            if self.fallback_to_stubs:
                return self.create_cat_engine()  # Will return stub
            raise
    
    def create_proactive_intelligence(self) -> Any:
        """Create proactive intelligence - production or stub."""
        if not self.use_production or not PROACTIVE_INTELLIGENCE_AVAILABLE:
            logger.info("Using stub proactive intelligence")
            # Return a simple stub
            class StubProactiveIntelligence:
                def __init__(self, *args, **kwargs):
                    self.priorities = {}
                
                def evaluate_action(self, action_data):
                    return {"risk_score": 0.1, "recommended": True}
                
                def update_priority(self, task_id, priority):
                    self.priorities[task_id] = priority
                    return True
            
            return StubProactiveIntelligence()
        
        try:
            # Create a production proactive intelligence
            pi_config = self.config.get("proactive_intelligence_config", {})
            proactive_config = ProactiveIntelligenceConfig(
                log_level=pi_config.get("log_level", "INFO"),
                simulation_depth=pi_config.get("simulation_depth", 3),
                risk_threshold=pi_config.get("risk_threshold", 0.7)
            )
            
            # We'll need the model_manager, try to get it from components first
            model_manager = self.components.get("model_manager") if hasattr(self, "components") else None
            
            # Initialize with None for vanta_core, it will be set later
            proactive_intelligence = ProactiveIntelligence(
                vanta_core=None,
                config=proactive_config,
                model_manager=model_manager
            )
            logger.info("Created production ProactiveIntelligence")
            return proactive_intelligence
        except Exception as e:
            logger.error(f"Error creating ProactiveIntelligence: {e}")
            if self.fallback_to_stubs:
                return self.create_proactive_intelligence()  # Will return stub
            raise
      def create_hybrid_cognition_engine(self) -> Any:
        """Create hybrid cognition engine - production or stub."""
        if not self.use_production or not HYBRID_COGNITION_AVAILABLE:
            logger.info("Using stub hybrid cognition engine")
            # Return a simple stub
            class StubHybridCognitionEngine:
                def __init__(self, *args, **kwargs):
                    self.branches = []
                
                def process_query(self, query, context=None):
                    return {"response": f"Processed: {query}", "confidence": 0.9}
                
                def get_active_branches(self):
                    return self.branches
            
            return StubHybridCognitionEngine()
        
        try:
            # Create a production hybrid cognition engine
            hce_config = self.config.get("hybrid_cognition_config", {})
            hybrid_config = HybridCognitionConfig(
                interval_s=hce_config.get("interval_s", 300),
                fusion_mode=hce_config.get("fusion_mode", "parallel"),
                log_level=hce_config.get("log_level", "INFO")
            )
            
            # Get instances of ToT and CAT engines if available
            tot_engine_instance = self.components.get("tot_engine", None)
            cat_engine_instance = self.components.get("cat_engine", None)
            
            # Initialize with None for vanta_core, it will be set later
            if tot_engine_instance is None or cat_engine_instance is None:
                # Create a stub since we can't create the real one without dependencies
                logger.warning("Cannot create HybridCognitionEngine: missing dependent engines. Creating stub instead.")
                return StubHybridCognitionEngine()
            
            # If we have the required dependencies, create the real engine
            hybrid_cognition_engine = HybridCognitionEngine(
                vanta_core=None,
                config=hybrid_config,
                tot_engine_instance=tot_engine_instance,
                cat_engine_instance=cat_engine_instance
            )
            logger.info("Created production HybridCognitionEngine")
            return hybrid_cognition_engine
        except Exception as e:
            logger.error(f"Error creating HybridCognitionEngine: {e}")
            if self.fallback_to_stubs:
                return StubHybridCognitionEngine()  # Return stub directly
            raise    def create_tot_engine(self) -> Any:
        """Create ToT engine - production or stub."""
        if not self.use_production or not TOT_ENGINE_AVAILABLE:
            logger.info("Using stub ToT engine")
            # Return a simple stub
            class StubToTEngine:
                def __init__(self, *args, **kwargs):
                    self.thoughts = []
                
                def process_thought(self, thought_data):
                    self.thoughts.append(thought_data)
                    return {"processed": True, "branch_id": f"branch_{len(self.thoughts)}"}
                
                def get_thought_tree(self):
                    return {"branches": self.thoughts}
            
            return StubToTEngine()
        
        try:
            # Create a production ToT engine
            tot_config = self.config.get("tot_engine_config", {})
            tot_engine_config = ToTEngineConfig(
                interval_s=tot_config.get("interval_s", 300),
                log_level=tot_config.get("log_level", "INFO")
            )
            
            # For the real implementation, we need to create or get the required specialist agents
            # Here we're creating basic versions for demonstration purposes
            class BasicThoughtSeeder:
                def generate(self, context, task_directives=None):
                    return [{"id": "seed1", "content": "Initial thought"}]
                
                def expand(self, branches, context, task_directives=None):
                    return branches + [{"id": f"branch_{len(branches)+1}", "content": "Expanded thought"}]
            
            class BasicBranchEvaluator:
                def score(self, branches, context, task_directives=None):
                    return {branch.get("id", f"branch_{i}"): 0.5 + (0.1 * i) 
                            for i, branch in enumerate(branches)}
            
            class BasicBranchValidator:
                def prune(self, branches, scores, task_directives=None):
                    # Keep branches with scores above 0.6
                    return [b for b in branches 
                            if scores.get(b.get("id", "unknown"), 0) > 0.6]
            
            class BasicMetaLearner:
                def integrate(self, branches, scores, context=None, memory_store=None):
                    # Just return the highest scored branch
                    if not branches:
                        return {"result": None, "confidence": 0}
                    
                    max_score = 0
                    best_branch = None
                    for branch in branches:
                        branch_id = branch.get("id", "unknown")
                        score = scores.get(branch_id, 0)
                        if score > max_score:
                            max_score = score
                            best_branch = branch
                    
                    return {"result": best_branch, "confidence": max_score}
            
            # Initialize with None for vanta_core, it will be set later
            # but with the required specialist agents
            tot_engine = ToTEngine(
                vanta_core=None,
                config=tot_engine_config,
                thought_seeder=BasicThoughtSeeder(),
                branch_evaluator=BasicBranchEvaluator(),
                branch_validator=BasicBranchValidator(),
                meta_learner=BasicMetaLearner()
            )
            logger.info("Created production ToTEngine")
            return tot_engine
        except Exception as e:
            logger.error(f"Error creating ToTEngine: {e}")
            if self.fallback_to_stubs:
                # Return a new stub instance directly
                return StubToTEngine()
            raise
      def create_all_components(self) -> Dict[str, Any]:
        """Create all components and return as dictionary."""
        components = {}

        logger.info("ðŸš€ Creating production components...")

        try:
            # Core components
            components["supervisor_connector"] = self.create_supervisor_connector()
            components["blt_encoder"] = self.create_blt_encoder()
            components["hybrid_middleware"] = self.create_hybrid_middleware()
            components["art_interface"] = self.create_art_interface()
            
            # New components
            components["stt_engine"] = self.create_stt_engine()
            components["tts_engine"] = self.create_tts_engine()
            components["processing_engine"] = self.create_processing_engine()
            components["echo_memory"] = self.create_echo_memory()
            components["memory_braid"] = self.create_memory_braid()
            components["sleep_time_compute"] = self.create_sleep_time_compute()
            
            # Save components for reference in other component creation methods
            self.components = components
            
            # Create components that might need references to other components
            components["cat_engine"] = self.create_cat_engine()
            components["proactive_intelligence"] = self.create_proactive_intelligence()
            components["hybrid_cognition_engine"] = self.create_hybrid_cognition_engine()
            components["tot_engine"] = self.create_tot_engine()

            # Log component types
            supervisor_type = type(components["supervisor_connector"]).__name__
            encoder_type = type(components["blt_encoder"]).__name__
            middleware_type = type(components["hybrid_middleware"]).__name__
            art_interface_type = type(components["art_interface"]).__name__
            stt_engine_type = type(components["stt_engine"]).__name__
            tts_engine_type = type(components["tts_engine"]).__name__
            processing_engine_type = type(components["processing_engine"]).__name__
            echo_memory_type = type(components["echo_memory"]).__name__
            memory_braid_type = type(components["memory_braid"]).__name__
            sleep_time_compute_type = type(components["sleep_time_compute"]).__name__
            cat_engine_type = type(components["cat_engine"]).__name__
            proactive_intelligence_type = type(components["proactive_intelligence"]).__name__
            hybrid_cognition_engine_type = type(components["hybrid_cognition_engine"]).__name__
            tot_engine_type = type(components["tot_engine"]).__name__

            logger.info("ðŸ“¦ Components created:")
            logger.info(f"  - Supervisor: {supervisor_type}")
            logger.info(f"  - Encoder: {encoder_type}")
            logger.info(f"  - Middleware: {middleware_type}")
            logger.info(f"  - ART Interface: {art_interface_type}")
            logger.info(f"  - STT Engine: {stt_engine_type}")
            logger.info(f"  - TTS Engine: {tts_engine_type}")
            logger.info(f"  - Processing Engine: {processing_engine_type}")
            logger.info(f"  - Echo Memory: {echo_memory_type}")
            logger.info(f"  - Memory Braid: {memory_braid_type}")
            logger.info(f"  - Sleep Time Compute: {sleep_time_compute_type}")
            logger.info(f"  - CAT Engine: {cat_engine_type}")
            logger.info(f"  - Proactive Intelligence: {proactive_intelligence_type}")
            logger.info(f"  - Hybrid Cognition Engine: {hybrid_cognition_engine_type}")
            logger.info(f"  - ToT Engine: {tot_engine_type}")

            return components

        except Exception as e:
            logger.error(f"âŒ Failed to create components: {e}")
            raise


def create_production_config() -> Dict[str, Any]:
    """Create default production configuration."""
    return {
        "use_production": True,
        "fallback_to_stubs": True,
        # Supervisor connector settings
        "voxsigil_library_path": None,  # Auto-detect
        "supervisor_instance": None,  # Will try to connect to existing
        # BLT encoder settings
        "blt_encoder": {
            "model_name": "all-MiniLM-L12-v2",
            "embedding_dim": 384,
            "cache_enabled": True,
            "cache_max_size": 5000,
            "use_gpu": False,  # Set to True if you have GPU setup
            "min_patch_size": 4,
            "max_patch_size": 8,
            "entropy_threshold": 0.5,
        },
        # Hybrid middleware settings
        "hybrid_middleware": {
            "enable_caching": True,
            "max_cache_size": 1000,
            "timeout_seconds": 30,
            "enable_compression": True,
        },
        # ART interface settings
        "art_interface": {
            "model_name": "text-davinci-003",
            "temperature": 0.7,
            "max_tokens": 150,
            "top_p": 1.0,
            "frequency_penalty": 0.0,
            "presence_penalty": 0.0,
        },
    }


def create_development_config() -> Dict[str, Any]:
    """Create development configuration with stubs enabled."""
    config = create_production_config()
    config.update(
        {
            "use_production": False,  # Use stubs for development
            "fallback_to_stubs": True,
        }
    )
    return config


def create_testing_config() -> Dict[str, Any]:
    """Create testing configuration."""
    config = create_production_config()
    config.update(
        {
            "use_production": False,  # Use stubs for testing
            "fallback_to_stubs": True,
            "blt_encoder": {
                **config["blt_encoder"],
                "cache_enabled": False,  # Disable cache for testing
            },
        }
    )
    return config


# Environment-based configuration
def get_config_for_environment(env: str = "development") -> Dict[str, Any]:
    """Get configuration for the specified environment."""
    if env.lower() in ["production", "prod"]:
        return create_production_config()
    elif env.lower() in ["testing", "test"]:
        return create_testing_config()
    else:
        return create_development_config()
